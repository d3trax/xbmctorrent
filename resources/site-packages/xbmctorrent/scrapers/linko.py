from xbmctorrent import plugin
from xbmctorrent.scrapers import scraper
from xbmctorrent.ga import tracked
from xbmctorrent.caching import cached_route
from xbmctorrent.utils import ensure_fanart
from xbmctorrent.linkog import linko_grabber, linko_unexpected_url
from xbmctorrent.utils import SafeDialogProgress
from contextlib import closing

BASE_URL = "http://www.linkomanija.net"
HEADERS = {
    "Accept-Encoding":"gzip",
    "Connection":"keep-alive",
    "DNT":"1",
    "Host":"www.linkomanija.net",
    "Referer": BASE_URL+"/index.php",
    "Accept-Language":"en-US,en;q=0.8,lt;q=0.6",
    "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36"
}
# Cache TTLs
DEFAULT_TTL = 24 * 3600 # 24 hours
LOCKS = {}
POOL_WORKERS = 4

LOGINS = {
    "user" : "",
    "pass" : ""
}
if plugin.get_setting("linko_user_name") and plugin.get_setting("linko_user_pass"):
    LOGINS['user'] = plugin.get_setting("linko_user_name")
    LOGINS['pass'] = plugin.get_setting("linko_user_pass")

grabber = linko_grabber(HEADERS, BASE_URL, LOGINS)

@scraper("Linko", "http://static.linkomanija.net/pic/blank_.gif")
@plugin.route("/linko")
@ensure_fanart
@cached_route()
@tracked
def linko_index():
    yield {"label": "RSS", "path": plugin.url_for("linko_rss_list", page=0)}
    def make_cats(root, prefix=""):
        for cat in root:
            yield {
                "label": "%s%s" % (prefix, cat['name']),
                "path": plugin.url_for("linko_page", cat=cat['value'], page=0),
            }

    with closing(SafeDialogProgress(delay_close=0)) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Fetching information...", line2="", line3="")
        try:
            cats = grabber.categories()
            i = 0
            for cat in make_cats(cats):
                dialog.update(
                    percent=int(i * 100.0 / len(cats)),
                    line2=""
                )
                i = i+1
                yield cat
        except linko_unexpected_url as x:
            plugin.notify("Unable to connect to %s." % BASE_URL)
            plugin.log.warning("Unable to connect to %s. %s" % (BASE_URL, x.message))
        dialog.close()

@plugin.route("/linko_search/<cat>")
@tracked
def linko_search(cat):
    import urllib

    query = plugin.request.args.get("query")
    if query:
        query = query[0]
    else:
        query = plugin.keyboard("", "Linko - Search")
    if query:
        plugin.redirect(plugin.url_for("linko_page", text=urllib.quote(query, safe=""), cat=cat, page=0, rtype="http"))

#todo: Need optimise http method for faster html parsing
def parseMoveInfo(id):
    #item = {}
    #meta = grabber.downloadDetails(id)
    return None
    # if meta is None:
    #     return None
    # if len(meta['images']) > 0:
    #     item['thumbnail'] = meta['images'][0]
    #     item['icon'] = meta['images'][0]
    #     if 'info' not in item:
    #         item['info'] = {}
    #     item['info']['plot'] = meta['text']
    # return item

@plugin.route("/linko_cat/<cat>/<page>")
@tracked
def linko_page(cat, page):
    from concurrent import futures
    from itertools import izip_longest
    import xbmc
    if cat is None:
        plugin.redirect(plugin.url_for("linko_index"))

    text = plugin.request.args_dict.get("text")
    rtype = plugin.request.args_dict.get("rtype")

    if text is None:
        text = ''

    page = int(page)

    plugin.log.info("Got linko_cat request: %s", str(plugin.request.args_dict))
    if rtype == "http":
        with closing(SafeDialogProgress(delay_close=0)) as dialog:
            dialog.create(plugin.name)
            dialog.update(percent=0, line1="Fetching information...", line2="", line3="")
            try:
                with futures.ThreadPoolExecutor(max_workers=POOL_WORKERS) as pool:
                    results = grabber.search(cat, text, page, xbmc, dialog)
                    i = 0
                    if dialog:
                        dialog.update(line2="Fetching additional data...", percent=0)
                    futures = []
                    for item in results:
                        if 'id' in item:
                            futures.append(pool.submit(parseMoveInfo, item["id"]))
                        else:
                            futures.append(None)

                    state = {"done": 0}
                    def on_item(future):
                        state["done"] += 1
                        dialog.update(
                            percent=int(state["done"] * 100.0 / len(filter(None, futures))),
                        )


                    [future.add_done_callback(on_item) for future in futures if future]
                    while not all(future.done() for future in futures if future):
                        if dialog.iscanceled():
                            return
                        xbmc.sleep(100)

                    details_list = [future and future.result() or None for future in futures]
                    if dialog:
                        dialog.update(line2="Combining data", percent=100)
                    for z, m in izip_longest(results, details_list):

                        if z is None:
                            continue

                        item = {
                            "label": z['name'],
                            "path": plugin.url_for("play", uri=z['magnet_uri']),
                            "is_playable": True
                        }

                        if m is not None:
                            item.update(m)

                        yield item
                        i = i+1

                    if i > 9:
                        yield {
                            "label": ">> Next page",
                            "path": plugin.url_for("linko_page", cat=cat, page=page + 1, text=text, rtype=rtype),
                            "is_playable": False,
                        }
            except linko_unexpected_url as x:
                plugin.notify("Unable to connect to %s. %s" % (BASE_URL, x.message))
                plugin.log.warning("Unable to connect to %s. %s" % (BASE_URL, x.message))

        dialog.close()
    if rtype == "rss":
        from xbmctorrent.utils import url_get
        from xbmctorrent.linkog import parse
        import xml.etree.ElementTree as ElementTree
        try:
            url = BASE_URL + "/rss.php?feed=dl&cat[]="+cat+"&passkey=fafec32e0299ce9e741d23bd48b40d36&page="+str(page)
            page_data = url_get(url, headers=HEADERS)
            for item in parse(page_data, url):
                yield item
            yield {
                "label": ">> Next page",
                "path": plugin.url_for("linko_page", cat=cat, page=page + 1, text=text, rtype=rtype),
                "is_playable": False,
            }
        except ElementTree.ParseError as e:
            plugin.log.error(e.message)
            if page > 2:
                raise e
            plugin.redirect(plugin.url_for("linko_page", cat=cat, page=page + 1, **plugin.request.args_dict))
            plugin.notify('Error loading ' + str(page) + ' page', 'Error parsing xml')

    if not rtype == "http" and text == '':
        yield {
            "label": ">> Http",
            "path": plugin.url_for("linko_page", cat=cat, page=page, rtype="http"),
            "is_playable": False,
        }
    if not rtype == "rss" and text == '':
        yield {
            "label": ">> Rss",
            "path": plugin.url_for("linko_page", cat=cat, page=0, rtype="rss"),
            "is_playable": False,
        }
    if text == '':
        yield {
            "label": ">> Search",
            "path": plugin.url_for("linko_search", cat=cat),
            "is_playable": False,
        }
    else:
        import urllib
        yield {
            "label": ">> Search '%s'" % urllib.unquote(text),
            "path": plugin.url_for("linko_search", cat=cat),
            "is_playable": False,
        }

@plugin.route("/linko_rss/<page>")
@tracked
def linko_rss_list(page):
    from xbmctorrent.utils import url_get
    from xbmctorrent.linkog import parse
    import urllib

    page = int(page)
    url = BASE_URL + "/rss.php?feed=dl%s" % (urllib.urlencode({
        'feed':'dl',
        'cat':[29, 52, 30, 60, 53, 61, 52, 51, 64, 65, 58],
        'passkey':'fafec32e0299ce9e741d23bd48b40d36'
    }))
    page_data = url_get(url, headers=HEADERS)
    for item in parse(page_data, url):
        yield item
    yield {
        "label": ">> Next page",
        "path": plugin.url_for("linko_rss_list", page=page + 1, **plugin.request.args_dict),
    }